# NMRFx Structure

NMRFx Structure can be used to generate and analyze macromolecular structures.  It can be run in two different ways.  First, if the command is invoked with one of several subcommands (gen, batch, score, predict) a predefined mode will be executed.  Alternatively, one can simply give as an argument a Python (actually Jython) script which will be executed.  The script has access to standard Python functions (including the standard Python library) and to specific commands provided by the NMRFx Structure program's Java code.

The predifined subcommands are listed here.  Project (.yaml) files are described below.

## gen

nmrfxstructure gen projectFile seed

Generate a single structure using data specified in a project file and initializing the random number generator with a specified seed.  This is useful for testing out the project file before generating a whole family of structures with the batch command.  An *output* directory will be created if not present.  The generated pdb file and a violation file will be written to that directory.  The output files will have the seed number appended to them (temp0.pdb, temp0.txt etc.)


For example,

**nmrfxstructure gen project.yaml 0**

## batch

nmrfxstructure batch -n nStructures -k keepNStructures -p useNProcesses -a projectFile 

Generate a family of structures using the data specified in a project file.  An *output* directory and *final* directory will be created if not present.  All generated structures will be written to files (temp1.pdb, temp2.pdb ...) in this directory.  A violation file (temp1.txt, temp2.text ...) will also be written.  The best structures (along with their violation files) will be written to the *final* directory. Multiple files are generated by repeatedly invoking the **nmrfxstructure gen** command with the specified project file and an incremented seed number.   The number of invocations running simultaneously will be specified by the **-p** argument.

For example,

**nmrfxstructure batch -n 100 -k 10 -p 5 -a project.yaml 0**

**-n** *nStructures* 
:  The total number of structures to generate.
	
**-k** *keepNStructures*  
:  Specify the number of structures to keep (and write to the *final* directory).  The structures with lowest total target function will be kept.

**-p** *useNProcesses* 
:  Structure generation can be sped up by running multiple structure calculation processes simultaneously.  This argument specifies the number of simultaneous calculations to perform.

**-s** *startNumber* 
:  Starting number for seed. This defaults to 0, but if you want to run batch a second time and generate additional structures you can specify this value.  Also used when submitting batch commands to multiple computers for higher level of parallelization.


**-a**
:  If this argument is specified then the structures will be automatically aligned and written to a new set of files (super1.pdb, super2.pdb ...).  During alignment defined regions of the structure (lower residue rms) will be identified and used for the alignmnent.


## score

nmrfxstructure score ?-o outDir? ?-p pdbs? ?-y projectFile? ?pdbFile1.pdb pdbFile2.pdb ...?

**-y** *projectFile* 
:  The project file that defines constraints to be used in the analysis.

**-o** *outDir* 
:  The directory in which to write output files.  Defaults to *analysis*.

**-p** *pdbFilePattern* 
:  PDB files can be specified as the final arguments to the command, or as an argument to this command.  This argument will result in execution of a Python level glob command to search for files that match the specified pattern. If wild card characteers (*) are specified then the whole pattern needs to be included in single quotes.

Examples:

**nmrfxstructure score -y project.yaml pdb/\*.pdb**

**nmrfxstructure score -y project.yaml -p 'pdb/\*.pdb'**





	
	
## Project Files

The molecular structure, constraints, and annealling parameters are defined in a project file.  This file uses the Yaml (Yaml Ain't Markup Language) format.  Yaml is a human readable data format that has a defined structure.  Unlike many markup or data languages it is free from a lot of actual markup fluff so is easy to read (and write).  Despite the apparent simplicity, remember that there is a defined formalism that must be followed.  For NMRFx Structure, you don't need to know much about Yaml files, you can simply work from existing examples.

The project file is best understood by reference to an example:

    molecule :
        sequence : GGCUCUGGUGAGAGCCAGAGCC
        residues : '1:2 125:135 217:225'
        ptype : RNA
    distances:
        -
          file : restraints1
          type : cyana
        -
          file : restraints2
          type : cyana
    angles:
        -
          file : restraints.aco
          type : cyana
    rna:
        ribose : Constrain

    anneal:
        steps : 15000
        highTemp : 5000.0

As used in NMRFx, the .yaml file has two primary uses of Yaml syntax.  Elements like **key : value** are used to set values of parameters (keys).  So, *sequence : GGUCU...*, indicates that the RNA (in this case) sequence is to be set to the value *GGCU...*.  The value for a key can itself contain multiple key/value pairs.  For example, the molecule section has multiple parameters (sequence, residues etc.).  The **-** characters precede elements of a list.  This example, has two distance restraint sections.

It's important to note that Yaml files use indentation to define the structure and that indenting should be done with multiple space characters, rather than tabs. The specific number of spaces does not matter, but elements nested at the same level should have a consistent number of spaces.

The currently supported sections are listed below:

**molecule**
:   This section specifies the molecular toplogy.  The polymer sequence can be specified directly in the .yaml file as shown here, or in an nvj style sequence file (using a file parameter).

    sequence : *sequence*
    :  The sequence, in single letter code form.

    file : *fileName*
    :  The path to a text file containing the sequence.

    ptype : *RNA* or *protein*
    :  The type of polymer sequence.

    type : *nv* or *fasta*
    :  The format of the file.  Either **nv**, in which it is the NMRViewJ format (similar to CYANA) with a single residue on each line, and an optional residue number, or fasta, in which case its the FASTA format.

    residues : *residueList*
    :  By default, residues are numbered starting at 1.  This parameter can be used to specify some other numbering scheme. Examples:

         '5'  : Start numbering at 5.
         1:2 125-130 200:207 : First two residues are numbered 1 and 2, The next six residues are numbered from 125 through 130 (inclusive), the remaining 8 residues are numbered from 200 through 207 (inclusive).
         

    link : *linkSpecifier*
    :  Structure calculations require that the molecular topology be one connected tree.  If there are multiple chains that are represented by one sequence item you can insert a break in the sequence with the link parameter.  The linkSpecifier is of the form **start:nLinks**, where **start** is the residue at which to insert a break, and **nLinks** is the number of linkers to use to allow flexibility between the chains.

**distances**
: This section specifies distance constraints to be used.  More than one distance constraint set can be used so this section is a Yaml list, with one or more elements.

    file : *fileName*
    :  The path to the file containing the constraints.

    type : *nv* or *cyana*
    :  The format of the file.  Either **nv**, in which it is the NMRViewJ format (similar to CYANA) with a single residue on each line, and an optional residue number, or cyana, in which case its the CYANA format.

    range : *rangeSpecifier*
    :  It can be convenient to have a file containing constraints appropriate to a super set of the sequence being used.  For example, you might have distance constraints for a large RNA, and want to analyze or generate structures that are a fragment of the whole molecule.  The **rangeSpecifier** is used to indicate that only constraints for residues within a certain range are to be used.

**angles**
: This section specifies angle constraints to be used.  More than one angle constraint set can be used so this section is a Yaml list, with one or more elements.

    file : *fileName*
    :  The path to the file containing the constraints.

    type : *nv* or *cyana*
    :  The format of the file.  Either **nv**, in which it is the NMRViewJ format (similar to CYANA) with a single residue on each line, and an optional residue number, or cyana, in which case its the CYANA format.

**rna**
: This section specifies angle constraints to be used.  More than one angle constraint set can be used so this section is a Yaml list, with one or more elements.

    ribose : *Constrain*
    :  If set to *Constrain*, automatically add distance constraints to maintain the ribose ring in a closed state..

    vienna : *DotBracketSequence*
    :  Specify the secondary structure using a dot-bracket (Vienna) string.  Whe performing a structure calculation this will automatically add distance constraints and dihedral angle constraints to maintain helices.  Dihedral angle constraints will also be added for GNRA tetraloops.

    suite : *fileName*
    :  The path to the file containing with a list of rotamer suites to be used to set angle constraints.


**anneal**
: This section specifies parameters to be used when running an annealing protocol using torsion angle molecular dynamics.

    steps : *nSteps*
    :  The total number of torsion angle molecular dynamcs steps to execute..

    highTemp : *highTemperature*
    :  The temperature to be used at the beginning of the annealing protocol.

